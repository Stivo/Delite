package ppl.delite.runtime.scheduler

import java.util.ArrayDeque
import ppl.delite.runtime.codegen.DeliteExecutable
import ppl.delite.runtime.graph.ops.DeliteOP

/**
 * Author: Kevin J. Brown
 * Date: Oct 11, 2010
 * Time: 4:34:43 PM
 *
 * Pervasive Parallelism Laboratory (PPL)
 * Stanford University
 */

/**
 * This class represents all the results generated by the walktime scheduler
 */
class StaticSchedule(val resources: Array[ArrayDeque[DeliteExecutable]]) {
  /**
   * Currently this class only holds a single scheduling object
   * The outer array represents the resources scheduled across
   * The inner ArrayDeque is the schedule for that resource
   * Designed to grow
   */
}

object PartialSchedule {
  def apply(startLocation: Int, endLocation: Int): PartialSchedule = {
    val r = new Array[ArrayDeque[DeliteOP]](endLocation - startLocation)
    for (i <- 0 until endLocation - startLocation) r(i) = new ArrayDeque[DeliteOP]
    new PartialSchedule(startLocation, endLocation, r)
  }

  def apply(startLocation: Int, endLocation: Int, resources: Array[ArrayDeque[DeliteOP]]): PartialSchedule = {
    new PartialSchedule(startLocation, endLocation, resources)
  }

  def apply(numResources: Int): PartialSchedule = apply(0, numResources)

  def apply(resources: Array[ArrayDeque[DeliteOP]]): PartialSchedule = apply(0, resources.length, resources)
}

class PartialSchedule(val startLocation: Int, val endLocation: Int, resources: Array[ArrayDeque[DeliteOP]]) extends Serializable {

  val numResources = endLocation - startLocation

  private def index(logical: Int) = logical - startLocation

  def apply(idx: Int) = resources(index(idx))

  def slice(start: Int, end: Int) = new PartialSchedule(start, end, resources.slice(index(start),index(end)))

  def foreach[U](f: ArrayDeque[DeliteOP] => U) = resources.foreach(f)

  def map[B](f: ArrayDeque[DeliteOP] => B) = resources.map(f)

  def withFilter(p: ArrayDeque[DeliteOP] => Boolean) = resources.withFilter(p)

  /**
   * Currently this class only holds a single scheduling object
   * The outer array represents the resources scheduled across
   * The inner ArrayDeque is the partial schedule of ops for that resource
   * Designed to grow
   */
}

/* TODO: hierarchical vs. flat?
object PartialClusterSchedule {
  def apply(numNodes: Int) = {
    new PartialClusterSchedule(new Array[PartialSchedule](numNodes))
  }

  def apply(resources: Seq[Int]) = {
    val nodes = new Array[PartialSchedule](resources.length)
    for (idx <- 0 until resources.length)
      nodes(idx) = new PartialSchedule(resources(idx))
    new PartialClusterSchedule(nodes)
  }

  def apply(nodes: Array[PartialSchedule]) {
    new PartialClusterSchedule(nodes)
  }
}

class PartialClusterSchedule(nodes: Array[PartialSchedule]) {

  val numNodes = nodes.length

  def apply(idx: Int) = nodes(idx)

  def foreach[U](f: PartialSchedule => U) = nodes.foreach(f)

  def map[B](f: PartialSchedule => B) = nodes.map(f)

  def withFiler(p: PartialSchedule => Boolean) = nodes.withFilter(p)

} */
