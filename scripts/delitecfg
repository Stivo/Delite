#!/bin/sh
script="/tmp/$(basename "$0").$(mktemp XXXX)"
cat "$(dirname "$0")/shared" > "$script"
echo 'try {' >> "$script"
echo '/\c' >> "$script"
echo '*\c' >> "$script"
cat "$0" >> "$script"
echo '} catch {' >> "$script"
echo 'case e: Exception => {' >> "$script"
echo 'var message = "%s".format(if (e.getMessage != null) e.getMessage else e.getCause )' >> "$script"
echo 'println(message)' >> "$script"
echo '}' >> "$script"
echo '}' >> "$script"
export script_home="$(dirname "$0")"
export script_name="$(basename "$0")"
exec scala "$script" "$@"
!#*/

class Scala(project: Project) {
  lazy val script = "println(current.buildCompiler.scalaInstance.compilerJar.getParentFile.getParentFile.getAbsolutePath)"
  lazy val home = project.invokeScript(script)(0)
  lazy val interpreter = (if (windows) "%s/bin/scala.bat" else "%s/bin/scala").format(home).replace("/", File.separator)
  lazy val compiler = (if (windows) "%s/bin/scalac.bat" else "%s/bin/scalac").format(home).replace("/", File.separator)
  lazy val compiler_jar = "%s/lib/scala-compiler.jar".format(home).replace("/", File.separator)
  lazy val library_jar = "%s/lib/scala-library.jar".format(home).replace("/", File.separator)
}

class Project(root: String, name: String) {
  def invokeScript(script : String) : List[String] = {
    val input_file = File.createTempFile("delitecfg.", ".input")
    input_file.delete
    val input_writer = new PrintWriter(input_file)
    input_writer.println("project %s".format(name))
    input_writer.println("console-project")
    input_writer.println(script)
    input_writer.println("exit")
    input_writer.println("exit")
    input_writer.close

    val output_file = File.createTempFile("delitecfg.", ".output")
    output_file.delete
    
    val sbt_windows_wrapper = File.createTempFile("delitecfg.", ".bat")
    val sbt_unix_wrapper = File.createTempFile("delitecfg.", "")
    val sbt_wrapper = if (windows) sbt_windows_wrapper else sbt_unix_wrapper
    sbt_wrapper.delete
    val sbt_wrapper_writer = new PrintWriter(sbt_wrapper)
    sbt_wrapper_writer.println("cd %s".format(root))
    val sbt_windows_path = config.script_home + File.separator + "sbt.bat"
    val sbt_unix_path = config.script_home + File.separator + "sbt"
    val sbt_path = if (windows) sbt_windows_path else sbt_unix_path
    sbt_wrapper_writer.println("%s <%s >%s".format(sbt_path, input_file.getAbsolutePath, output_file.getAbsolutePath))
    sbt_wrapper_writer.close

    sbt_wrapper.setExecutable(true)
    Runtime.getRuntime().exec(sbt_wrapper.getAbsolutePath).waitFor

    val lines = Source.fromFile(output_file).getLines.toList
    val lines_without_prefix = (lines dropWhile {_ != "scala> " + script} drop 1).toList
    (lines_without_prefix takeWhile {!_.startsWith("scala> ")}).toList dropRight 1
  }

  lazy val scala = {
    new Scala(this)
  }

  lazy val deps = {
    val script = "current.mainDependencies.all.getPaths foreach println"
    invokeScript(script)
  }

  def dep(q : String) = {
    val results = (deps filter {_.contains(q)}).toList
    if (results.length == 0) "not found" else results(0)
  }

  lazy val target = {
    val script = "println(current.mainCompilePath.absolutePath)"
    invokeScript(script)(0)
  }
}

// script code begins here

println("Detecting the location of Delite...")
try {
  val delite_home = config.delite_home
  config.validate_delite_home()
  config.clear()
  config.delite_home = delite_home
} catch {
  case _ => {
    config.clear()
    print("Please, enter home directory of Delite: ")
    config.delite_home = readLine
  }
}
println("Delite's home directory: %s%n".format(config.delite_home))

val framework = new Project(config.delite_home, "Delite Framework")
val optiml = new Project(config.delite_home, "OptiML")
val dsls = new Project(config.delite_home, "DSLs")
val scala_apps = new Project(config.delite_home, "Scala Apps")
val applications = new Project(config.delite_home, "Applications")
val delite = new Project(config.delite_home, "Delite")
val runtime = new Project(config.delite_home + File.separator + "runtime", "runtime")

configureScalapath("scala_virtualized", "scala virtualized", framework.scala)
configureScalapath("scala_vanilla", "scala vanilla", runtime.scala)
configureClasspath("lms_classes", "LMS", framework.dep("virtualization-lms-core"))
configureClasspath("framework_classes", "Framework", framework.target)
configureClasspath("optiml_classes", "OptiML", optiml.target)
configureClasspath("runtime_classes", "Runtime", runtime.target)

def configureScalapath(key: String, description: String, scala: Scala) = {
  println("Detecting the location of %s...".format(description))
  println("%s home: %s%n".format(description.capitalize, scala.home))

  config(key + "_home") = scala.home
  config(key + "_interpreter") = scala.interpreter
  config(key + "_compiler") = scala.compiler
  config(key + "_library_jar") = scala.library_jar
  config(key + "_compiler_jar") = scala.compiler_jar
}

def configureClasspath(key: String, description: String, classpath: => String) = {
  println("Detecting the location of %s...".format(description))
  println("%s's main compile path: %s%n".format(description.capitalize, classpath))

  config(key) = classpath
}

